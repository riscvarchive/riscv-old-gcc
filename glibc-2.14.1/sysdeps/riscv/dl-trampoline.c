/* PLT trampoline.  MIPS version.
   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*  FIXME: Profiling of shared libraries is not implemented yet.  */

#include <sysdep.h>
#include <link.h>
#include <elf.h>
#include <ldsodefs.h>
#include <dl-machine.h>

/* Get link map for callers object containing STUB_PC.  */
static inline struct link_map *
elf_machine_runtime_link_map (ElfW(Addr) gpreg, ElfW(Addr) stub_pc)
{
  extern int _dl_mips_gnu_objects;

  /* got[1] is reserved to keep its link map address for the shared
     object generated by the gnu linker.  If all are such objects, we
     can find the link map from current GPREG simply.  If not so, get
     the link map for caller's object containing STUB_PC.  */

  if (_dl_mips_gnu_objects)
    {
      ElfW(Addr) *got = elf_mips_got_from_gpreg (gpreg);
      ElfW(Word) g1;

      g1 = ((ElfW(Word) *) got)[1];

      if ((g1 & ELF_MIPS_GNU_GOT1_MASK) != 0)
	{
	  struct link_map *l =
	    (struct link_map *) (g1 & ~ELF_MIPS_GNU_GOT1_MASK);
	  ElfW(Addr) base, limit;
	  const ElfW(Phdr) *p = l->l_phdr;
	  ElfW(Half) this, nent = l->l_phnum;

	  /* For the common case of a stub being called from the containing
	     object, STUB_PC will point to somewhere within the object that
	     is described by the link map fetched via got[1].  Otherwise we
	     have to scan all maps.  */
	  for (this = 0; this < nent; this++)
	    {
	      if (p[this].p_type == PT_LOAD)
		{
		  base = p[this].p_vaddr + l->l_addr;
		  limit = base + p[this].p_memsz;
		  if (stub_pc >= base && stub_pc < limit)
		    return l;
		}
	    }
	}
    }

    struct link_map *l;
    Lmid_t nsid;

    for (nsid = 0; nsid < DL_NNS; ++nsid)
      for (l = GL(dl_ns)[nsid]._ns_loaded; l != NULL; l = l->l_next)
	{
	  ElfW(Addr) base, limit;
	  const ElfW(Phdr) *p = l->l_phdr;
	  ElfW(Half) this, nent = l->l_phnum;

	  for (this = 0; this < nent; ++this)
	    {
	      if (p[this].p_type == PT_LOAD)
		{
		  base = p[this].p_vaddr + l->l_addr;
		  limit = base + p[this].p_memsz;
		  if (stub_pc >= base && stub_pc < limit)
		    return l;
		}
	    }
	}

  _dl_signal_error (0, NULL, NULL, "cannot find runtime link map");
  return NULL;
}

/* Define mips specific runtime resolver. The function __dl_runtime_resolve
   is called from assembler function _dl_runtime_resolve which converts
   special argument registers t5 (x17) and t6 (x18):
     t5  address to return to the caller of the function
     t6  index for this function symbol in .dynsym
   to usual c arguments.

   Other architectures call fixup from dl-runtime.c in
   _dl_runtime_resolve.  MIPS instead calls __dl_runtime_resolve.  We
   have to use our own version because of the way the got section is
   treated on MIPS (we've also got ELF_MACHINE_PLT defined).  */

/* The flag _dl_mips_gnu_objects is set if all dynamic objects are
   generated by the gnu linker. */
int _dl_mips_gnu_objects = 1;

#define VERSYMIDX(sym)  (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (sym))

/* This is called from assembly stubs below which the compiler can't see.  */
static ElfW(Addr)
__dl_runtime_resolve (ElfW(Word), ElfW(Word), ElfW(Addr), ElfW(Addr))
		  __attribute_used__;

static ElfW(Addr)
__dl_runtime_resolve (ElfW(Word) sym_index,
		      ElfW(Word) return_address,
		      ElfW(Addr) old_gpreg,
		      ElfW(Addr) stub_pc)
{
  struct link_map *l = elf_machine_runtime_link_map (old_gpreg, stub_pc);
  const ElfW(Sym) *const symtab
    = (const ElfW(Sym) *) D_PTR (l, l_info[DT_SYMTAB]);
  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
  ElfW(Addr) *got
    = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
  const ElfW(Word) local_gotno
    = (const ElfW(Word)) l->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;
  const ElfW(Word) gotsym
    = (const ElfW(Word)) l->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
  const ElfW(Sym) *sym = &symtab[sym_index];
  struct link_map *sym_map;
  ElfW(Addr) value;

  /* FIXME: The symbol versioning stuff is not tested yet.  */
  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)
    {
      switch (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
	{
	default:
	  {
	    const ElfW(Half) *vernum =
	      (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
	    ElfW(Half) ndx = vernum[sym_index] & 0x7fff;
	    const struct r_found_version *version = &l->l_versions[ndx];

	    if (version->hash != 0)
	      {
		sym_map = _dl_lookup_symbol_x (strtab + sym->st_name, l,
					       &sym, l->l_scope, version,
					       ELF_RTYPE_CLASS_PLT, 0, 0);
		break;
	      }
	    /* Fall through.  */
	  }
	case 0:
	  sym_map = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym,
					 l->l_scope, 0, ELF_RTYPE_CLASS_PLT,
					 DL_LOOKUP_ADD_DEPENDENCY, 0);
	}

      /* Currently value contains the base load address of the object
	 that defines sym.  Now add in the symbol offset.  */
      value = (sym ? sym_map->l_addr + sym->st_value : 0);
    }
  else
    /* We already found the symbol.  The module (and therefore its load
       address) is also known.  */
    value = l->l_addr + sym->st_value;

  /* Apply the relocation with that value.  */
  *(got + local_gotno + sym_index - gotsym) = value;

  return value;
}

#define ELF_DL_FRAME_SIZE (10*SZREG)

#define ELF_DL_SAVE_ARG_REGS "\
	" STRINGXP(REG_S) " t5, 9*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a0, 1*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a1, 2*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a2, 3*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a3, 4*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a4, 5*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a5, 6*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a6, 7*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " a7, 8*" STRINGXP(SZREG) "(sp)\n						      \
"

#define ELF_DL_RESTORE_ARG_REGS "\
	" STRINGXP(REG_L) " ra, 9*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a0, 1*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a1, 2*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a2, 3*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a3, 4*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a4, 5*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a5, 6*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a6, 7*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " a7, 8*" STRINGXP(SZREG) "(sp)\n						      \
"

/* The PLT resolver should also save and restore $2 and $3, which are used
   as arguments to MIPS16 stub functions.  */
#define ELF_DL_PLT_FRAME_SIZE (12*SZREG)

#define ELF_DL_PLT_SAVE_ARG_REGS \
	ELF_DL_SAVE_ARG_REGS "\
	" STRINGXP(REG_S) " v0, 10*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_S) " v1, 11*" STRINGXP(SZREG) "(sp)\n						      \
"

#define ELF_DL_PLT_RESTORE_ARG_REGS \
	ELF_DL_RESTORE_ARG_REGS "\
	" STRINGXP(REG_L) " v0, 10*" STRINGXP(SZREG) "(sp)\n						      \
	" STRINGXP(REG_L) " v1, 11*" STRINGXP(SZREG) "(sp)\n						      \
"

asm ("\n\
	.text\n\
	.align	2\n\
	.globl	_dl_runtime_resolve\n\
	.type	_dl_runtime_resolve,@function\n\
	.ent	_dl_runtime_resolve\n\
_dl_runtime_resolve:\n\
	.frame	sp, " STRINGXP(ELF_DL_FRAME_SIZE) ", ra\n\
	" STRINGXV(SETUP_GP64(t4, _dl_runtime_resolve)) "\n\
	# Save arguments and sp value in stack.\n\
	addi  sp, sp, " STRINGXP(-ELF_DL_FRAME_SIZE) "\n\
	# Save slot call pc.\n\
	move	v0, ra\n\
	" ELF_DL_SAVE_ARG_REGS "\
	move	a0, t6\n\
	move	a1, t5\n\
	move	a2, v1\n\
	move	a3, v0\n\
	" STRINGXV(PIC_JAL(t4, __dl_runtime_resolve)) "\n\
	" ELF_DL_RESTORE_ARG_REGS "\
	move	t7, v0\n\
	addi	sp, sp, " STRINGXP(ELF_DL_FRAME_SIZE) "\n\
	jr	t7\n\
	.end	_dl_runtime_resolve\n\
	.previous\n\
");

/* Assembler veneer called from the PLT header code when using PLTs.

   Code in each PLT entry and the PLT header fills in the arguments to
   this function:

   - x17 (t5) - caller's return address
   - x18 (t6) - PLT entry index
   - x19 (t7) - address of _dl_runtime_pltresolve
   - x14 (t2) - address of .got.plt

   Different registers are used for .got.plt because the ABI was
   originally designed for o32, where gp was available (call
   clobbered).  On n32/n64 gp is call saved.

   _dl_fixup needs:

   - x4 (a0) - link map address
   - x5 (a1) - .rel.plt offset (== PLT entry index * 8)  */

asm ("\n\
	.text\n\
	.align	2\n\
	.globl	_dl_runtime_pltresolve\n\
	.type	_dl_runtime_pltresolve,@function\n\
	.ent	_dl_runtime_pltresolve\n\
_dl_runtime_pltresolve:\n\
	.frame	sp, " STRINGXP(ELF_DL_PLT_FRAME_SIZE) ", ra\n\
	" STRINGXV(SETUP_GP64(t4, _dl_runtime_pltresolve)) "\n\
	# Save arguments and sp value in stack.\n\
1:	addi	sp, sp, " STRINGXP(-ELF_DL_PLT_FRAME_SIZE) "\n\
	" STRINGXP(REG_L) "	t1, " STRINGXP(PTRSIZE) "(t2)" "\n\
	" ELF_DL_PLT_SAVE_ARG_REGS "\
	move	a0, t1\n\
	sll	a1, t6, " STRINGXP(PTRLOG) " + 1\n\
	" STRINGXV(PIC_JAL(t4, _dl_fixup)) "\n\
	move	t7, v0\n\
	" ELF_DL_PLT_RESTORE_ARG_REGS "\
	addi	sp, sp, " STRINGXP(ELF_DL_PLT_FRAME_SIZE) "\n\
	jr	t7\n\
	.end	_dl_runtime_pltresolve\n\
	.previous\n\
");

